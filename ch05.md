# Chapter 5

The solution of the previous chapter is implemented in this chapter. You should still be able to navigate to the products page and the clients page.

Make sure to run `npm install` as we added some additional background libraries for our small component lib. The component lib is expanded with the following components:

Also make sure that from this point the jworks demo backend app is running!

- `src/components/ActionButton`
- `src/components/ActionButtonMenu`
- `src/components/Page`
- `src/components/Table`

## Retrieve data from the server

If we navigate to the product page, in the end we would like to have a table displaying all the products we have. First step to do that is actually have some products by making a call to a server.
In Angular, this is done by the `HttpClient` module that ships with Angular by default. React.js does not ship with something like that by default. It is as previously mentioned a UI library and not a framework. This allows you to choose whatehever you like to retrieve your data from the server. In this chapter we will use [API](_https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API_).

In Angular we put something like this in a `Service`. We will kinda do the same for our products feature

1. Create the Product type by running `touch src/products/types/product.ts` and paste the following inside it:

```jsx harmony
export interface Product {
  id: string;
  name: string;
  description: string;
  productCode: string;
}
```

2. Create the service by running `touch src/products/services/products.ts` and export the following function:

```jsx harmony
export async function getProducts(): Promise<Product[]> {
  const response = await fetch("http://localhost:8080/products");

  return response.json();
}
```

## Retrieve the products in the ProcuctPage container app

Paste the following in `src/products/containers/ProductsPage/ProductsPage.tsx`:

```jsx harmony
import React, { useState, useEffect } from "react";
import { Product } from "../../types/Product";
import { getProducts } from "../../services/products";
import { Table, Page } from "../../../components";

export function ProductsPage() {
  const [products, setProducts] = useState<Product[] | undefined>(undefined);
  const rehydrateProducts = async () => setProducts(await getProducts());

  /* NEW */
  useEffect(() => {
    rehydrateProducts();
  }, []);

  return (
    <Page title="Products" onCreateButtonClick={() => {}}>
      <Table
        headers={["Id", "Name", "Description", "Product Code"]}
        data={products}
        onEdit={() => {}}
        onDelete={() => {}}
      ></Table>
    </Page>
  );
}
```

### The useEffect hook

In the above snipet you see the usage of the `useEffect` hook. We already discussed the `useState` hook.
The useEffect hook can do bassicly the same thing that Angular does with it's lifecycling methods.
When retrieving data in an angular application, most likly this will take place in the `ngOnInit` lifecycle hook.

We can achieve the same result with the `useEffect` hook. The first argument is a function where you can do what you have to do, in our case we want to retrieve products. By default, the useEffect will trigger whenever the state or props change. If we do this:

```jsx harmony
useEffect(() => {
  rehydrateProducts();
});
```

We will cause an infinite loop, Everytime `rehydrateProducts` ran, we update the state, causing an other trigger to rerun. By default it acts like the angular `ngOnChanges` or react `componentDidUpdate` life cycle hook. That is not what we want, we want to run this one time. So how do we do this?

The second param is an empy array, this will prevent the useEffect hook to call every time the state or props changes and so it will act as the angular `ngOnInit` or the react`componentDidMount` life cycle methods. The array tells the useEffect hook when it specifivly need to rerender, as it is empty, it will not look out for any state changes. When no second param is given, by default, every change will be detected and the hook will run again.

More info about useEffect can be found [here](_https://reactjs.org/docs/hooks-effect.html_).

## Result

You should see now a table with our products! And you discoverd that lifecycle methods are not needed at all in this chapter, how neat is that!
