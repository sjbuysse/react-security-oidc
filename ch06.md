# Chapter 6

We just learned how to do data fetching and work with the lifecycles of a component (using a `useEffect` hook).
We also already know how to route and create components. We're almost there for the basics! Let's create a form
so that we can create and edit any client.

## Create a client

By the end of this chapter, it should be possible to create a product. Following will be added:

- The component lib is extended with some extra components to create the form (`FieldErrors`,`InputField`,`SubmitButton`,`TextAreaField`).
- A new function in our service to create a product
- Add the necessary routing and changes to our `ClientsPage` component
- We will create the ClientForm component

### Update our clients.ts service

Add the following function to `src/clients/services/clients.ts`:

```jsx harmony
export async function createClient(
  client: Partial<Client>
): Promise<Client[]> {
  const response = await fetch("http://localhost:8080/clients", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(client),
  });

  return response.json();
}
```

When clicking the "Add" button, a dialog should apear with the text "ProducForm component".
Also when navigating directly to `http://localhost:3000/products/create` will open immidiatly the dialog component.

### Create our ProductForm component

Next up we replace the "ProducForm component" component with an actual `ProductForm` component:

- `mkdir src/products/components/ProductForm`
- `touch src/products/components/ProductForm/ProductForm.tsx`

And paste the following:

```jsx harmony
import React, { useState } from "react";
import { TextAreaField, InputField, SubmitButton } from "../../../components";
import { FormField } from "../../../models";
import { Product } from "../../types";

export interface ProductFormFields {
  name: FormField;
  description: FormField;
  productCode: FormField;
}

interface Props {
  product?: Partial<Product>;
  onSubmit: (product: Partial<Product>) => void;
}

export function ProductForm({ product = {}, onSubmit }: Props) {
  const [isFormDirty, setIsFormDirty] = useState < boolean > false;
  const [fields, setFields] =
    useState <
    ProductFormFields >
    {
      name: {
        value: product.name || "",
        errors: [],
      },
      description: {
        value: product.description || "",
        errors: [],
      },
      productCode: {
        value: product.productCode || "",
        errors: [],
      },
    };
  const { name, description, productCode } = fields;
  const getValidationErrors = (key: string, value: string): string[] => {
    switch (key) {
      case "name":
        return value.trim().length === 0 ? ["Name is required"] : [];
      case "productCode":
        return value.trim().length === 0 ? ["Product code is required"] : [];
      default:
        return [];
    }
  };
  const isFormValid =
    Object.entries(fields).reduce(
      (amountOfErrors, [key, field]) =>
        amountOfErrors + getValidationErrors(key, field.value).length,
      0
    ) === 0;
  const handleOnChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const key = e.target.name;
    const value = e.target.value;
    const errors = getValidationErrors(key, value);

    setFields({
      ...fields,
      [key]: {
        value,
        errors,
      },
    });
  };
  const handleOnSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();

    if (isFormDirty === false) {
      setFields({
        name: {
          ...name,
          errors: getValidationErrors("name", name.value),
        },
        description: {
          ...description,
          errors: getValidationErrors("description", description.value),
        },
        productCode: {
          ...productCode,
          errors: getValidationErrors("productCode", productCode.value),
        },
      });

      setIsFormDirty(true);
    }

    if (isFormValid) {
      onSubmit({
        name: name.value,
        description: description.value,
        productCode: productCode.value,
      });
    }
  };

  return (
    <form className="w-full" onSubmit={handleOnSubmit}>
      <InputField
        hasFocus
        name="name"
        label="Name"
        value={name.value}
        errors={name.errors}
        onChange={handleOnChange}
      ></InputField>
      <TextAreaField
        name="description"
        label="Description"
        value={description.value}
        errors={description.errors}
        onChange={handleOnChange}
      ></TextAreaField>
      <InputField
        name="productCode"
        label="Product Code"
        value={productCode.value}
        errors={productCode.errors}
        onChange={handleOnChange}
      ></InputField>
      <SubmitButton isDisabled={!isFormValid && isFormDirty}></SubmitButton>
    </form>
  );
}
```

It does look a bit scary in the beginning but if you read trough it, it is actually not that hard to understand.
This is one of the advantages of react. This reads almost as plain javascript.
The following component can also be reused when we will edit a product for the next chapter.

### Add the `ProductForm` component in our `CreateProductDialog` container

We can now replate the "ProducForm component" text with the `ProductForm` component.
Go to `src/products/containers/CreateProductDialog/CreateProductDialog.tsx` and change the following:

```jsx harmony
...
import { ProductForm } from "../../components/ProductForm/ProductForm";
...
export function CreateProductDialog({ onClose, onSubmit }: Props) {
  return (
    <Dialog show title="Create product" onClose={onClose}>
      {/* NEW */}
      <ProductForm onSubmit={onSubmit}></ProductForm>
    </Dialog>
  );
}
```

### Update our ProductPage container again

Finally we need actually call our service wheb the onSubmit button fires with a product.
Go to `src/products/containers/ProductPage/ProductPage.tsx` and change the following:

```jsx harmony
...
import { getProducts, addProduct } from "../../services";
...
export function ProductsPage() {
  ...
  const onCreateProduct = async (newProduct: Partial<Product>) => {
    await addProduct(newProduct);
    await rehydrateProducts();
    push(url);
  };
  ...
  return (
    <>
      ...
      <Route exact path={`${url}/create`}>
        <CreateProductDialog
          onClose={() => push(url)}
          {/* NEW */}
          onSubmit={onCreateProduct}
        ></CreateProductDialog>
      </Route>
    </>
  );
}
```
