As a bonus exercise, try to display the `CreateProduct` and `EditProduct` components in a modal.
For this, we'll use the ReachUI `Dialog` component
```
npm install @reach/dialog --save
```
Check out the [Reach Dialog documentation](https://reach.tech/dialog), and wrap both the 
`CreateProduct` component and the `EditProduct` component in a `Dialog` component.

The trick to get this to work nicely with `react-router` is to use 2 sibling `Switch` components,
and to remove the `exact` keyword in the first route, so that it will match with any route that begints with `products/`.
Now, when you route for example to `products/create`, in both `Switch` components there will be a matching route.
So both routes will be rendered at the same time. This results in a modal of `EditProduct` with a background of `ProductsTable`.

```tsx
<>
    <Switch>
        <Route path={url}>
            <Page title="Products" onCreateButtonClick={gotToCreateProduct}>
                <ProductsTable></ProductsTable>
            </Page>
        </Route>
    </Switch>
    <Switch>
        <Route path={`${url}/create`}>
            {/*here should come a dialog*/}
        </Route>
        <Route path={`${url}/:productId/edit`}>
            {/*here should come a dialog*/}
        </Route>
    </Switch>
</>
```

## re-fetch data on history change
There's still 1 bug in the code now. If you edit a product, and save it, you will return to `products/`.
But since this route was already matched in the first `Switch` it will not re-render, and so the data will be stale!
To fix this, we can subscribe to any changes on the `history` object in the `ProductsTable`,
and re-fetch the data when the location changes.

```tsx
const history = useHistory();
useEffect(() => {
    return history.listen(() => retrieveProducts())
},[history]);
```
